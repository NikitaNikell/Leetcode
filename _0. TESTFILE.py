# 2) lambda_func:

# применяем lambda к каждому элементу списка
numbers = [1, 2, 3, 4, 5]
squares = list(map(lambda x: x ** 2, numbers))
#print(squares) # [1, 4, 9, 16, 25]

# при помощи lambda фильтруем по чётности
numbers_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers_1))
#print(even_numbers)


# передаём lambda в качестве аргумента key для сортировки
mylist = ['111', '22', '3']
mylist_sort = sorted(mylist, key = lambda x: len(x))
#print(mylist_sort)


#3) Что такое docstring?
# Docstring в Python - это строка документации, которая описывает, что делает функция, метод, модуль или класс Python.
# Данная строка располагается в начале определения объекта и используется для генерации документации автоматически.
# В других словах, docstring используется для создания описания API и содержит информацию о том, как использовать функцию
# или метод, какие аргументы они принимают и какие значения возвращают.

def add_numbers(a, b):
    """
    This function takes in two numbers and returns their sum
    """
    return a + b

#print(add_numbers.__doc__)
#help(add_numbers)


#4) В чём разница между типами list и tuple?
"""
Основная разница между ними заключается в том, что список может быть изменен (мутабельный тип),
а кортеж является неизменяемым (иммутабельным типом).

Различие в изменяемости во многом определяет отличие между списком и кортежем в скорости доступа к элементам. 
За счет того, что кортежи являются неизменным типом данных, они обрабатываются быстрее, чем списки.

"""

my_list = [1, 2, 3, 4, 5]  # Это список
my_tuple = (1, 2, 3, 4, 5)  # Это кортеж


a = [1, 2, 3, 4]
[a.append(i) for i in my_list]
#print(a)


# 5) Как просмотреть методы объекта?

"""
Чтобы посмотреть все методы и атрибуты, связанные с определенным объектом в Python, можно использовать функцию dir(). 
Она принимает объект в виде аргумента и возвращает список имен всех атрибутов и методов объекта.
"""

my_list = [1, 2, 3]
#print(dir(my_list))

#6) Что такое *args и **kwargs в определении функции?

"""
*args и **kwargs - это специальные параметры в Python, которые позволяют передавать 
переменное количество аргументов в функцию.

Параметр *args используется для передачи переменного количества аргументов без ключевого слова. 
Он представляет собой кортеж из всех дополнительных аргументов, переданных функции.

Параметр **kwargs используется для передачи переменного количества именованных аргументов. 
Он представляет собой словарь из всех дополнительных именованных аргументов, переданных функции.
"""

def my_fun(a, b, *args):
    print(a, b, args)

#my_fun(1, 2, 3, 4, 5) # 1 2 (3, 4, 5)


def my_fun(a, b, **kwargs):
    print(a, b, kwargs)

#my_fun(1, 2, x=3, y=4, z=5) # 1 2 {'x': 3, 'y': 4, 'z': 5}


#7) Python полностью поддерживает ООП?
""" Да, Python является полностью объектно-ориентированной языком. 
Он поддерживает все основные принципы ООП: наследование, инкапсуляцию и полиморфизм.

В Python все объекты в явном виде являются экземплярами классов, и даже типы данных, такие как список или словарь, 
являются классами со своими методами и атрибутами.

Кроме того, Python поддерживает множественное наследование, который позволяет создавать новые классы, 
которые наследуют методы и атрибуты от нескольких родительских классов одновременно.

В целом, Python предоставляет множество инструментов для написания кода в объектно-ориентированном стиле, 
и это один из главных его преимуществ, особенно для написания крупных и сложных приложений.
"""


#8) Что такое globals() и locals()?
"""globals() и locals() - это встроенные функции в Python, которые возвращают словари глобальных и локальных переменных соответственно.

globals() возвращает словарь, содержащий все глобальные переменные, доступные в текущей области видимости, включая встроенные переменные.
locals() возвращает словарь, содержащий все локальные переменные, определенные в текущей области видимости. Это включает аргументы функции и переменные,
которым присвоено значение внутри функции. 
"""

x = 5
y = 10

def my_func(z):
    a = 3
    print(globals()) # выводит все глобальные переменные
    print(locals()) # выводит все локальные переменные

#my_func(7)


#9) Что такое декоратор? Как написать собственный?

""" 
Декоратор в Python - это функция, которая принимает другую функцию в качестве аргумента и расширяет ее 
функциональность без изменения ее кода. Декораторы могут использоваться для добавления логирования, 
проверки аутентификации, тайминга выполнения и ещё кучи полезных штук.
"""


# def my_decorator(func):
#     def wrapper():
#         print("Дополнительный код, который исполняется перед вызовом функции")
#         func()
#         print("Дополнительный код, который исполняется после вызова функции")
#
#     return wrapper
#
#
# @my_decorator
# def say_hello():
#     print("Привет!")
#
#
# say_hello()


# from time import time
#
#
# def executiontime(func):
#     """
#     Вот, к примеру, декоратор, который позволяет измерять время выполнения функции:
#     """
#     def wrapper():
#         start = time()
#         func()
#         end = time()
#         print(f'Функция {func} выполнялась: {end - start} сек')
#
#     return wrapper
#
#
# @executiontime
# def create_tuple():
#     return tuple(range(13**7))
#
#
# create_tuple()

#10)

def my_generator(n):
    for i in range(n + 1):
        yield i

my_gen = my_generator(5)
[print(next(my_gen)) for i in range(5+1)]